# 项目笔记 -- 

### 简易版RPC框架初识：
RPC（Remote Procedure Call）远程过程调用，允许计算机在不同的计算机之间进行通信交互，像本地调用一样
RPC的利用可以让我们使用已经开发过的功能模块，提高开发效率

一个最简单的RPC框架包含服务提供者、服务消费者；消费者通过代理对象来发送请求，在网络传输过程中
Java对象的传输需要进行序列化 通过将对象转化为字节流的方式传输，去请求RPC服务器，
服务提供者需要把提供的服务注册到服务注册器中，提供相应的服务方法


### 全局配置加载：
由于RPC框架是需要被其他项目作为服务提供者或者服务消费者引入的，RPC框架中设计到很多配置
不应该是硬编码而是可以自定义，允许框架通过编写配置文件来自定义配置，一般情况下服务提供者和消费者
需要编写相同的配置

配置一套全局配置加载功能，能够使RPC框架轻松从配置文件中读取配置，并且维护一个全局配置对象，便于
框架快速获取到一致的配置。

首先需要创建一个配置对象类，里面包含RPC框架所对应的属性，比如：名称、版本号、服务器主机、端口等等
创建一个工具类ConfigUtils用来读取对应的配置文件并且返回配置文件对应的java对象（返回一个配置对象）
此工具类应该设计为容易扩展，其方法的返回值应当为一个泛型，根据传进来的类型返回。

在ConfigUtils工具类中设计了一个方法，接受的参数为Class<T>泛型字节码文件，还有一个配置文件属性前缀
参数1泛型字节码文件用来指定根据配置文件转化为相应类的java配置对象
参数2是用来读取配置文件中前缀对应的属性
利用hutool工具包的Props类型，根据配置文件名生成props对象，利用toBean方法指定转化类型以及配置前缀来
返回一个配置对象

#### RPC框架应用初始化
提供一个方法init用户初始化RPC框架应用，需要维护一个volatile修饰的RpcConfig类型的变量
作用是初始化来返回一个配置对象（所以它使用的类型是配置类）

volatile关键字表示当前变量是一个可以共享的变量，在多线程的环境下可以让其他线程访问到，它的原理是
每次从主存中读取该变量的值并拷贝一份给每个线程。
volatile有一个缺点就是不具备原子性 所以我们需要借助双重检验锁来实现这个RPC框架的单例模式

提供一个getRpcConfig方法，首先进行判断是否为空，判断完毕之后对其进行加锁，加锁对象为当前类字节码，
加锁完毕再给对象赋值初始化
为什么要在加锁之后再进行是否为空判断？ -- 由于JVM重排序特点，对一个变量进行赋值时，大概可以分为三步
1、给这个变量分配内存空间   2、变量初始化     3、将这个变量指向分配的内存空间
这三步在单线程（单环境）下没问题，但是在多线程下，有可能顺序为132,此时如果有一个线程过来执行此方法
会导致返回一个未初始化的变量，从而导致线程安全问题。

### Mock--模拟对象
mock是指模拟对象，用来模拟远程调用行为，因为实际开发中因为一系列缘故可能无法真实访问远程服务
在这种情况下，我们采用mock来测试业务，跑通业务流程。

我们需要在RpcConfig配置类中添加一个属性为 mock 用来判断是否开启mock。
新生成一个代理类，MockServiceProxy，利用反射的原理根据调用方法的返回值来进行生成指定类型的对象测试
利用设计模式中的工厂模式，来生成Mock的代理对象，在ServiceProxyFactory提供一个方法用来获取
MockServiceProxy代理对象，由于反射的机制，在调用工厂模式生成代理对象的时候，会返回一个代理对象
调用其方法，会进入到代理对象中的方法，进行业务逻辑判断，

### 序列化器与SPI机制
对于一个RPC框架，序列化器的选择应该要多样，可供挑选，所以不应该硬编码
除了Jdk原生的序列化器之外，我们还提供三种不同的序列化器可供选择：JSON、Hessian、Kryo
SPI（Service Provider Interface）服务接口提供 --是Java的机制，用于模块化开发和插件化开发
SPI机制允许服务提供者通过特定的配置文件将自己的实现注入到系统中，然后系统通过反射机制动态加载，不需要修改
框架原有的代码，提高扩展性

在resource目录下创建 META-INF目录，这个目录用来存放项目的配置文件、扩展程序等，相当于一个信息包
自定义SPI实现的话需要利用到 序列化器的名称 => 序列化器实现类对象的映射关系

以此创建JSON、Kryo、Hessian三种主流的序列化器类，参考代码即可
可以定义一个类为序列化器常量类，使用接口实现

利用工厂模式，创建一个序列化器工厂，每次执行序列化操作都不需要重新创建一个对象，避免资源的消耗
RpcConfig配置类中需要添加一个属性为默认的Serializer序列化方式

自定义序列化器SPI机制实现 参考Dubbo的实现进行设计，编写SpiLoader加载器类
关键点：
1、用map存储已加载的配置信息， 键名=>实现类
2、扫描指定路径，读取指定路径下的配置文件，获取键名=>实现类信息并存储到map中
3、定义获取序列化器类加载器的方法，根据用户传入的接口和键名，从map中找到对应的实现类，
通过反射机制获取到实现类对象，维护每一个对象实例缓存，创建过的对象直接从缓存中读取

最后在序列化器工厂中使用，SPI机制来指定序列化器对象，静态代码块调用load方法初始化Spi类加载器

